#+title: LISP-Kurs
#+author: Sebastian Jordan
#+latex_header: \usepackage[ngerman]{babel}

* Einfuehrung
** Themen
   * Rekursion
   * Concurrency
   * Streams & Lazy evaluation

** Material
   * [[https://www.gnu.org/software/mit-scheme/][MIT-Scheme]] :: Downloadlinks und Manual
   * [[https://www.gnu.org/software/emacs/][Emacs]] :: Programmiereditor mit gutem LISP-Support
   * [[http://www.vim.org/][Vim]] :: Standard Linuxtexteditor der auf fast allen Systemen
            installiert ist (Vi)
   * [[https://mitpress.mit.edu/sicp/][Structure and Interpretation of Computer Programs]] :: Das Buch
        zum Kurs
   * Guile

* Anleitung fuer dieses Dokument
  Dieses Dokument enthaelt sehr viel Schemecode.  Du kannst den Code
  extrahieren, sofern du GNU Make und Emacs auf deinem System
  installiert hast.  Fuehre einfach den Befehl
  #+begin_src sh
    make all
  #+end_src
  im Verzeichnis aus, in dem die Datei =lessons.org= liegt.  Eine
  pdf-Version dieses Dokuments wird ebenfalls erzeugt, sofern =latex=
  auf deinem System installiert ist.

* Ein Beispiel: Wurzel nach Newtonverfahren
  #+caption: =sqrt-newton.scm=
  #+begin_src scheme :tangle sqrt-newton.scm
    (define (sqrt-newton x)
      ;; iteration step
      (define (sqrt-iter guess)
        (if (good-enough? guess)
            guess
            (sqrt-iter (improve guess))))

      ;; test if we are already good enough with our guess
      (define (good-enough? guess)
        (<= (abs (- (square guess) x)) 0.0001))

      ;; square a number
      (define (square n) (* n n))

      ;; improve a guess
      (define (improve guess)
        (avarage guess (/ x guess)))

      (define (avarage a b)
        (/ (+ a b) 2.0))

      ;; start the iteration with 1 as initial guess
      (sqrt-iter 1))

    ;; test the function
    (define test (sqrt-newton 4))
    (display "Die Wurzel von 4 ist ")
    (display test)
    test
  #+end_src

  #+RESULTS:
  : 2.0000000929222947

  Diese Beispiel findest du unter dem Namen =sqrt-newton.scm=, wenn du
  die =.scm=-Dateien gemaess der obigen Anleitung erzeugt hast.

* (Haus-)aufgaben
  * 1.1
  * 1.3
  * 1.8

* Wiederholung: Funktionen & Blockstruktur
** Aufgabe 1.3
   Hier ist eine Beispielloesung fuer die Aufgabe 1.3 aus dem Buch:
   
   #+begin_src scheme
     (define (add-and-mult a b c)
       (define (second-greatest m n o)
         (if (and (<= m n) (<= m o))
             (min n o)
             (if (and (<= n m) (<= n o))
                 (min m o)
                 (min m n))))
       (define greatest max)
       (define (square x) (* x x))
       (+ (square (second-greatest a b c)) 
          (square (greatest a b c))))

     ;; test the function
     (add-and-mult 4 2 3)
   #+end_src

   Das Ergebnis des Tests:
   #+RESULTS:
   : 25

** Aufgabe 1.8
   Zum Loesen der Aufgabe 1.8 verwenden wir die selbe Strategie wie
   fuer das Finden der Quadratwurzel.  Wir veraendern allerdings die
   =improve=-Funktion.

   #+begin_src scheme
     (define (cuberoot-newton x)
       (define (cubert-iter guess)
         (if (good-enough? guess)
             guess
             (cubert-iter (improve guess))))
       (define (good-enough? guess)
         (>= 0.001
             (abs (- (cube guess) x))))

       ;; new improve function
       (define (improve guess)
         (/ (+ (* 2. guess) (/ x (square guess)))
            3.))

       (define (cube n) (* n (square n)))
       (define (square n) (* n n))
       (cubert-iter 1))

     ;; test the function
     (cuberoot-newton 125.0)
   #+end_src
 
   #+RESULTS:
   : 5.000000000287929

* Rekursion
  Wir wollen die Fakultaet einer Zahl berechnen.  Dazu Uebertragen wir
  die definition der Fakultaet in Scheme.

  \begin{align}
    !x &= x \cdot !(x - 1) \\
    !0 &= 1
  \end{align}

  Eine intuitivie Definition der Fakultaet koennte folgende sein:
  #+begin_src scheme
    (define (factorial x)
      (if (<= x 1)
          1                           ;; base case
          (* x (factorial (- x 1))))) ;; recursive step

    ;; test the function
    (factorial 6)
  #+end_src

  Das Ergebnis unseres Tests:
  #+RESULTS:
  : 720

  Dies ist eine vereinfachte Darstellung der Auswertung der obigen
  Funktion.  Wie wir sehen koennen, benoetigt die Funktion "linear
  viel" Speicher.
  #+begin_src scheme
    (factorial 5)
    (* 5 (factorial 4))
    (* 5 (* 4 (factorial 3)))
    (* 5 (* 4 (* 3 (factorial 2))))
    (* 5 (* 4 (* 3 (* 2 (factorial 1)))))
    (* 5 (* 4 (* 3 (* 2 1))))
    (* 5 (* 4 (* 3 2)))
    (* 5 (* 4 6))
    (* 5 24)
    120
  #+end_src

  Unser Ziel ist es, nur konstant viel Speicher -- also unabhaengig
  von der eingegebnene Zahl -- zu verbrauche.  Dazu wandeln wir die
  rekursive Definition der Fakultaet in einen iterativen Prozess um.
  #+begin_src scheme
    (define (factorial x)
      (define (iter accu count)
        (if (= count x)
            (* count accu)
            (iter (* accu count) (+ count 1))))
      (iter 1 1))

    (factorial 5)
  #+end_src

  #+RESULTS:
  : 120

  Fuer eine Iteration benoetigen wir (genauso wie in Python und Co)
  nur konstant viel Speicher.  Hier ist dargestellt wie der
  Interpreter den Funktionskoerper der obigen Funktion auswerten
  koennte.
  #+begin_src scheme
    (define x 3)
    (iter 1 1)
    (iter 1 2)
    (iter 2 3)
    6
  #+end_src

** Fibonacci
   
   Die ersten 10 Elemente der Fibonaccireihe.

   | fib(n) | 0 | 1 | 1 | 2 | 3 | 5 | 8 | 13 | 21 | 34 |
   |--------+---+---+---+---+---+---+---+----+----+----+
   | n      | 1 | 2 | 3 | 4 | 5 | 6 | 7 |  8 |  9 | 10 |

   Eine rekursive Definition der Reihe:
   \begin{equation}
     fib(n) = fib(n -1) + fib(n - 2)
   \end{equation}

   Hier ist eine Pseudoimplementation der Fibnoaccireihe:
   #+begin_src
     int a <- 0
     int b <- 1
     for i in (3..n)
       int c <- a + b
       a <- b
       b <- c
     return b
   #+end_src

   Als Uebungsvorschlag: Du koenntest versuchen, die Fibonaccireihe
   als Rekursion & Iteration zu implementieren (Siehe Fakultaet).

* Wiederholung: Rekursion & Iteration

  Eine rekursive Beispielimplementation:
  #+begin_src scheme
    (define (fib-rec n)
      (cond ((< n 1) (error "FIB-REC: index to small"))
            ((= n 1) 0)
            ((= n 2) 1)
            ((> n 2) (+ (fib-rec (- n 1)) (fib-rec (- n 2))))))
    (fib-rec 10)
  #+end_src

  #+results:
  : 34

  Hier ist eine iterative Beispielimplementation der Fibonaccizahlen.
  #+begin_src scheme
    (define (fib-iter n)
      (define (iter counter n-1 n-2)
        (if (= counter n)
            n-1
            (iter (1+ counter) (+ n-1 n-2) n-1)))

      (cond ((= n 1) 0)
            ((= n 2) 1)
            (else (iter 2 1 0))))
  #+end_src

  #+results:
  : 34

* Listen
  Listen bestehen aus Paaren.

** Paare
   Paare sind zusammengesetzte Datenstrukturen, das heisst, dass sich
   Paare in kleinere Bestandteile zerlegen lassen und, vor allem, sich
   aus kleineren Bestandteilen zusammen bauen lassen.

   Paare sind "Behaelter", die genau 2 Werte speichern koennen.  Es
   gibt einen "ersten" Wert und einen "zweiten" Wert, eindeutig
   Adressierbar sein muessen.

   Es folgt eine Beispielinterface fuer das Programmieren mit Paaren:
   #+begin_src scheme
     (define (pair a b)
       (error "PAIR: undefined"))
     (define (1st p)
       (error "1ST: undefined"))
     (define (2nd p)
       (error "2ND: undefined"))

     ;; What would you get?
     (1st (pair 1 2)) ;; 1
     (2nd (pair 1 2)) ;; 2

     (1nd (2nd (2nd (pair 1 
                          (pair 2
                                (pair 3
                                      4))))))
     ;; 3
   #+end_src

*** Und in Scheme?
    In Scheme sind die =pair=-, =1st=- und =2nd=-Funktion schon definiert.

    * pair == cons
    * 1st == car
    * 2nd == cdr

    Beispiel fuer =car=:
    #+begin_src scheme
      (define new-pair (cons 1 2))
      (car new-pair)
    #+end_src

    #+results:
    : 1

    Beispiel fuer =cdr=:
    #+begin_src scheme
      (define new-pair (cons 1 2))
      (cdr new-pair)
    #+end_src

    #+results:
    : 2

    Andere nuetzliche Funktionen im Zusammenhang mit Paaren:
    #+begin_src scheme
      (pair? (cons 1 2)) ;; #t
      (pair? 1) ;; #f

      #nil ;; #nil ist der sogenannte Nullzeiger und signalisiert KEINEN
           ;; Wert.
      (null? #nil) ;; #t
      (null? 1) ;; #f
    #+end_src

** Definition der Primitiven
   Hier ist eine Definition von "Paaren" (ohne =pair?=).
   #+caption: =<<custom-definition-pairs>>=
   #+name: custom-definition-pairs
   #+begin_src scheme
     (define (my-cons a b)
       (define (dispatch mode)
         (cond ((= mode 1) a)
               ((= mode 2) b)
               (else (error "COND: Argument not [1..3] -- " mode))))
       dispatch)

     (define (my-car list)
       (list 1))

     (define (my-cdr list)
       (list 2))
   #+end_src

   Auswertung der Implementation per Befehlssubstitution:
   #+begin_src scheme
     ;; testevaluation (KOMMENTIEREN)
     (my-car (my-cons 5 8))
     ;; zuerst werten wir den Rueckgabewert von my-cons aus.  my-cons gibt
     ;; uns eine Funktion zurueck (dispatch), die hier durch das lambda
     ;; dargestellt wird.
     (my-car (lambda (mode) (cond ((= mode 1) 5)
                                  ((= mode 2) 8))))

     ;; Jetzt wird my-car ausgewertet.  my-car "bewirkt" dass das Argument
     ;; (also in diesem Fall die "lambda"-Funktion ein Argument bekommt und
     ;; dann ausgewertet wird.
     ((lambda (mode)
        (cond ((= mode 1) 5)
              ((= mode 2) 8)))
      1)

     ;; Nun wird der Aufruf der "lambda"-Funktion durch den Koerper der
     ;; Funktion ersetzt.
     ((define mode 1)
      (cond ((= mode 1) 5)
            ((= mode 2) 8)))
     5
   #+end_src

** Jetzt wirklich Listen
   Listen sind in Scheme einfach nur "geschachtelte" Paare.
   #+caption: =<<definitions-lists>>=
   #+name: definitions-lists
   #+begin_src scheme :tangle definitions-lists.scm
     ;; definitions-lists
     ;;;;;;;;;;;;;;;;;;;;
     
     (define empty-list #nil)

     (define (list-empty? list) (null? list))

     ;; put an element in front of the list
     (define (prepend elem list)
       (cons elem list))

     ;; put an element in the end of a list
     (define (append list elem)
       (if (null? list)
           (cons elem #nil)
           (cons (car list) (append (cdr list) elem))))

     ;; get the first element of a list
     (define (head list)
       (cond ((pair? list) (car list))
             ((null? list) (error "HEAD: list is empty"))
             (else (error "HEAD: object is not a list"))))

     ;; get all but the first element of a list
     (define (tail list)
       (cond ((pair? list) (cdr list))
             ((null? list) (error "TAIL: list is empty"))
             (else (error "TAIL: object is not a list"))))

     ;; get all but the last element of a list
     (define (init list)
       (cond ((null? list) (error "INIT: empty list given"))
             ((null? (cdr list)) #nil)
             (else (cons (car list)
                         (init (cdr list))))))

     ;; get the last element of a list
     (define (last list)
       (cond ((null? list) (error "LAST: empty list given"))
             ((null? (cdr list)) (car list))
             (else (last (cdr list)))))

     ;; get the n-th element of a list (starting with 0)
     (define (index list n)
       (if (= n 0)
           (car list)
           (index (cdr list) (1- n))))
   #+end_src

** Generalisierung
   Wenn wir mit Listen zu tun haben, dann kommen bestimmte "Probleme"
   oft vor.  Betrachten wir zum Beispiel das folgende Stueckchen Code:

   #+caption: =map-example-01.scm=
   #+begin_src scheme :tangle map-example-01.scm :noweb no-export
     <<definitions-lists>>

     ;; This procedure adds 1 to every element
     (define (add-one list)
       (if (list-empty? list)
           empty-list
           (prepend (1+ (head list))
                    (add-one (tail list)))))

     (define numbers '(1 2 3 4))
     (display "The original list is ")
     (write numbers)
     (newline)
     (display "add-one applied to the list results in ")
     (write (add-one numbers))
     (newline)

     ;; This procedure multiplies every element by 2
     (define (mult-two list)
       (if (list-empty? list)
           empty-list
           (prepend (* 2 (head list))
                    (mult-two (tail list)))))

     (define numbers '(1 2 3 4))
     (display "The original list is ")
     (write numbers)
     (newline)
     (display "mult-two applied to the list results in ")
     (write (mult-two numbers))
     (newline)
   #+end_src

   Beide Funktionen machen etwas sehr Aehnliches.  Es wird ueber eine
   Liste iteriert.  Dabei wird auf jedes Element eine Operation
   angewendet und so eine neue Liste erzeugt.

   #+begin_example scheme
     (define (<function> list)
       (if (list-empty? list)
           empty-list
           (prepend (<operation> (head list))
                    (<function> (tail list)))))
   #+end_example

   Die Generalisierung dieser beider Funktionen wird =map= genannt.
   Wir koennen diese Idee allgemein in Scheme formulieren:

   #+caption: =<<definition-map>>=
   #+name: definition-map
   #+begin_src scheme :noweb no-export
     (define (map operation list)
       (if (list-empty? list)
           empty-list
           (prepend (operation (head list))
                    (map operation (tail list)))))
   #+end_src

   #+begin_src scheme :noweb no-export :tangle map-example-02.scm
     <<definitions-lists>>
     <<definition-map>>

     (define (add-one list)
       (map 1+ list))

     (define (mult-two list)
       (map (lambda (x)
              (* 2 x))
            list))

     (write (mult-two '(1 2 3 4 5)))
     (write (add-one '(1 2 3 4 5)))
   #+end_src

** Hausaufgabe
   Wir stellen uns einmal vor, dass wir eine Liste von Zahlen gegeben
   haben und wollen alle Zahlen aufsummieren.  Der Code dafuer wurde
   wohl in etwa folgendermasse aussehen:

   #+begin_src scheme :tangle sum-example.scm :noweb no-export
     ;; We have to include the definitions for our list primitives
     <<definitions-lists>>

     (define (sum-list list)
       (define (iter accu current)
         (if (list-empty? current)
             accu
             (iter (+ accu (head current)) (tail current))))
       (iter 0 list))

     (define numbers '(1 2 3 4 5 6))
     (display "The sum of ")
     (write numbers)
     (display " is ")
     (write (sum-list numbers))
     (newline)       
   #+end_src

   Wie koennen wir diese Funktion generalisieren?  Wenn du im Internet
   recherchieren willst, dann suche nach den Stichworten =fold=, =left
   fold=, =foldl=, wie zum Beispiel [[https://duckduckgo.com/?q%3Dscheme%2Bfold&t%3Dffab][hier]] (der Link funktioniert aus
   irgendeineem Grund nicht auf der github-Seite) geschehen.

*** Loesung
    Die =sum-list= Funktion macht prinzipiell 2 Dinge:
    1. Die Funktion iteriert ueber die List (so wie in =map=).
    2. Die Funktion akkumuliert Werte, die in der Liste gespeichert
       sind mittels einer Kombinationsfunktion.

    #+caption: =<<definition-foldl>>=
    #+name: definition-foldl
    #+begin_src scheme
      (define (foldl accu-fun start list)
        (cond ((list-empty? list) start)
              (else (foldl accu-fun
                           (accu-fun start (head list))
                           (tail list)))))

    #+end_src

    Wir koennen nun die =foldl=-Funktion fuer verschiedene Dinge nutzen:
    #+begin_src scheme :tangle foldexamples.scm :noweb no-export
      ;; We have to include list primitives
      <<definitions-lists>>
      ;; ... and foldl
      <<definition-foldl>>
      <<definition-map>>

      ;; The sum function
      (define (sum list) (foldl + 0 list))

      ;; The length function
      (define (length list)
        (foldl (lambda (accu e)
                 (1+ accu))
               0
               list))

      (define (length-fancy list)
        (sum (map (lambda (x) 1) list)))

      (define (map-pair fun pair)
        (cons (fun (car pair)) (fun (cdr pair))))

      (define (foldl-pair fun start pair)
        (fun (fun start (car pair)) (cdr pair)))

      (list 1+ (lambda (x) (* 2 x)))
      (define wert 10)

      ;; We can even define a filter function
      (define (filter predicate list)
        (foldl (lambda (accu-list current)
                 (if (predicate current)
                     (append accu-list current)
                     accu-list))
               empty-list
               list))
    #+end_src

    #+caption: =<<definition-filter>>=
    #+name: definition-filter
    #+begin_src scheme
      (define (filter pred list)
        (foldr (lambda (x accu)
                 (if (pred x)
                     (prepend x accu)
                     accu))
               empty-list
               list))
    #+end_src

** foldr
   Manchmal wollen wir aber auch ueber eine Liste von "hinten" aus
   iterieren.  Aehnlich wie =foldl= wollen wir eine
   Accumulationsfunktion und einen Startwert angeben koennen.  Die
   Funktion soll dabei jedes Element nur einmal ansehen.

   #+caption: =<<definition-foldr>>=
   #+name: definition-foldr
   #+begin_src scheme
     (define (foldr f start list)
       (cond ((null? list) start)
             (else (f (car list)
                      (foldr f start (cdr list))))))
   #+end_src

** Hausaufgaben
   * =mkList= :: Hat 1 Argument, n.  Soll Liste der Laenge n erzeugen,
                 mit nur 1en drin.
                 #+begin_src scheme
                   (define (mkList n)
                     (cond ((= n 0) #nil)
                           (else (cons 1 (mkList (- n 1))))))

                 #+end_src
   * =mkNumbers= :: Hat 1 Argument, n.  Soll Liste erzeugen, mit den
                    Zahlen 1 bis n.
                    #+begin_src scheme
                      (define (mkNumbers n)
                        (define (iter current)
                          (cond ((= current n) #nill)
                                ((< current n)
                                 (cons (+ 1 current) (iter (+ 1 current))))
                                (else (error "Internal error"))))
                        (iter 0))

                      (define (mkNumbers2 n)
                        (define (iter current acc)
                          (cond ((= current n) acc)
                                ((< current n) (iter (+ 1 current) (append acc (+ 1 current))))))
                        (iter 0 #nil))

                      (define (mkNumber3 n)
                        (if (= n 0)
                            #nil
                            (append (mkNumber3 (- n 1)) n)))


                    #+end_src
   * =iter-list= :: Hat 3 Argumente
     * iter-fun :: Ist eine Funktion, die ein Argument hat
     * start-val :: Hat den passenden Typen zu iter-fun
     * n :: Integer, so viele Elemente soll die Liste am Ende haben
     #+caption: =<<definition-iter-list.scm>>=
     #+name: definition-iter-list.scm
     #+begin_src scheme :tangle iter-list.scm
       (define (iter-list fun start len)
         (define (iter current current-elem)
           (cond ((= current len) #nil)
                 ((< current len)
                  (cons current-elem (iter (+ 1 current) (fun current-elem))))
                 (else (error "Internal error"))))
         (iter 0 start))
     #+end_src               

   #+begin_src scheme
     (iter-list 1+ 0 10)
     ;; '(0 1 2 3 4 5 6 7 8 9)

     (iter-list (lambda (x) (cons 1 x)) empty-list 3)
     ;; '(#nil '(1) '(1 1)) 
   #+end_src

** The List dropth the List taketh
   Manchmal sind wir an den ersten n Elementen einer Liste
   interessiert.  Wir koennen dann entsprechend oft =head= und =tail=
   anwenden.

   #+begin_src scheme
     (define (first-3-elems xs)
       (list (head xs) (head (tail xs)) (head (tail (tail xs)))))
   #+end_src

   Die Funktion =first-3-elems= gibt nimmt eine Liste entgegen und
   gibt eine neue Liste zurueck, die die ersten 3 Elemente enthaelt.
   Wir koennen diese Funktion abstrahieren zu einer einer Funktion,
   die eine Liste und eine Zahl n entgegen nimmt und die ersten n
   Elemente der Liste zurueck gibt.

   #+caption: =<<definition-take>>=
   #+name: definition-take
   #+begin_src scheme
     (define (take n xs)
       (cond ((= n 0) empty-list)
             ((list-empty? xs)
              (error "-- TAKE: tried to get an element from the empty list"))
             (else (cons (head xs) (take (1- n) (tail xs))))))
   #+end_src

   Analog dazu koennen wir auch eine Funktion definieren, die die
   ersten n Elemente einer Liste verwirft und den "Rest" zurueck gibt.

   #+caption: =<<definition-drop>>=
   #+name: definition-drop
   #+begin_src scheme
     (define (drop n xs)
       (cond ((= 0 n) xs)
             ((list-empty? xs)
              (error "-- DROP: cannot drop another element from the empty list"))
             (else (drop (1- n) (tail xs)))))
   #+end_src

** Was noch fehlt... Sortieren!
   Wir haben gelernt, wie wir

   * Listen (mit Hilfe von "higher order functions" erzeugen koenne
   * primitive Operationen auf Listen durchfuehren koennen, die
     einzelne Elemente der Liste manipulieren
   * wiederkehrende Operationen abstrahieren koennen und "higher order
     functions" nutzen koennen um weniger ( = besseren) Code zu
     schreiben.

   Wir haben noch nicht gelernt, wie wir Listen sortieren.  Hier ist
   eine Beispielimplementation von Quicksort.  Sie sortiert eine Liste
   von Zahlen aufsteigend der Groesse nach.

   #+begin_src scheme :tangle quicksort-example.scm :noweb no-export
     <<definitions-lists>>
     <<definition-map>>
     <<definition-foldl>>
     <<definition-foldr>>
     <<definition-filter>>

     (define (concat l1 l2)
       (foldr (lambda (x accu)
                (prepend x accu))
              l2
              l1))

     (define (concat3 l1 l2 l3)
       (concat l1
               (concat l2 l3)))

     (define (quicksort numbers)
       (define (qs)
         (let* ((pivot (head numbers))
                (lower (filter (lambda (x) (< x pivot))
                               (tail numbers)))
                (bigger (filter (lambda (x) (>= x pivot))
                                (tail numbers))))
           (begin
             (write lower)
             (display " ")
             (write pivot)
             (display " ")
             (write bigger)
             (newline)
             (concat3 (quicksort lower)
                      (list pivot)
                      (quicksort bigger)))))
       
       (cond ((list-empty? numbers) empty-list)
             (else (qs))))
   #+end_src

   Leider ist die Verwendung dieser Funktion darauf beschraenkt,
   Zahlen der Groesse nach zu sortieren. Wir koennen diese
   Beispielimplementation abstrahieren, indem wir "offen" lassen,
   welche Vergleichsoperation beim Vergleich verwendet werden soll.
   Auf diese Art koennen wir alle Listen nach beliebigen Kriterien
   sortieren.

   #+name: definition-sort
   #+begin_src scheme
     (define (quicksort smaller-than xs)
       (if (list-empty? xs)
           empty-list
           (let*
               ((pivot (head xs))
                (non-pivot (tail xs))
                (< (lambda (x) (smaller-than x pivot)))
                (>= (lambda (x) (not (smaller-than x pivot))))
                (smaller (filter < non-pivot))
                (bigger (filter >= non-pivot)))
             (concat3 (quicksort smaller-than smaller)
                      (list pivot)
                      (quicksort smaller-than bigger)))))

     ;; Hier ist noch eine Implementation von mergesort
     (define (mergesort smaller-or-equal-than xs)
       (define (merge as bs)
         (cond ((list-empty? as) bs)
               ((list-empty? bs) as)
               (else (let
                         ((a (head as))
                          (b (head bs)))
                       (if (smaller-or-equal-than a b)
                           (prepend a
                                    (merge (tail as) bs))
                           (prepend b
                                    (merge as (tail bs))))))))
       (let*
           ((len (length xs))
            (first-half (take (quotient len 2) xs))
            (second-half (drop (quotient len 2) xs)))
         (if (<= (length xs) 1)
             xs
             (merge (mergesort smaller-or-equal-than
                               first-half)
                    (mergesort smaller-or-equal-than
                               second-half)))))
   #+end_src
   
   Der Vollstaendigkeit halber, hier noch einmal die Definition von
   =concat3= sauber notiert.

   #+name: definition-concat.scm
   #+begin_src scheme
     (define (concat l1 l2)
       "Concatenate l1 with l2"
       ;; We choose foldr to prepend all the elements of l1 to l2.  If we
       ;; chose to fold from the left and append every element of l2 to l1,
       ;; we would had a runtime behavior of O(n*m + n^2/2) where
       ;;
       ;; * n = length of l1
       ;; * m = length of l2
       ;;
       ;; This way we have O(n) as runtime behavior. (Why?)
       (foldr (lambda (current accu)
                (prepend current accu))
              l2
              l1))

     (define (concat3 l1 l2 l3)
       "Concatenate 3 lists l1 l2 l3"
       ;; First we concatenate l3 and l2, which in turn gets concatenated
       ;; with l1, which gives us a runtime behavior of $ O(n + m) $ where
       ;;
       ;; * n = length of l1
       ;; * m = length of l2
       ;; ( What would be the runtime behavior of
       ;;   (concat (concat l1 l2) l3)
       ;;   ?)
       (concat l1
               (concat l2
                       l3)))
   #+end_src

** Zusammenfassung, eine kleine Library
   Bis hier her haben wir uns angesehen, was wir alles mit Listen
   anstellen koennen.  Wir haben gelernt wie wir Listen als Paare
   darstellen koennen und haben sogar Paare als Funktionen
   dargestellt.  Wir haben mathematische Probleme effizient geloest
   (Fibonacci, Fakultaet) und daraus wiederkehrende Prozesse zu
   Funktionen abstrahiert.  Die Funktionen, die wir dabei definiert
   haben, koennen wir zu einer Library zusammenfassen.  Wir nennen sie
   =lists.scm=.
   
   #+name: lists.scm
   #+caption: lists.scm
   #+begin_src scheme :tangle lib/lists.scm :noweb no-export
     <<definitions-lists>>
     <<definition-map>>
     <<definition-foldl>>
     <<definition-foldr>>
     <<definition-filter>>
     <<definition-iter-list>>
     <<definition-take>>
     <<definition-drop>>
     ;; We have to define concat3 before the sorting algorithms because we
     ;; use these in their definition.
     <<definition-concat>>
     <<definition-sort>>
   #+end_src

* Streams
  Streams sind (so, wie Listen auch) Abstaktionen ueber Daten.  Wir
  stellen uns Streams als (un-)endlich lange Sammlung von Daten vor,
  die wir nacheinander abrufen koennen.  Ein Stream muss folgenden
  Gesetzmaessigkeiten gehorchen:

  * =(car-stream (cons-stream a b))= = =a=
  * =(cdr-stream (const-stream a b))= = =b=

  Das sieht ja erstmal genauso wie die Definition einer Liste aus.  Es
  gibt aber einen kleinen Unterschied zwischen Listen uns Streams:
  Streams berechnen ihr die enthaltenen Werte nur auf Abruf.

  #+begin_src scheme :tangle strict-map.scm :noweb no-export
    <<definitions-lists>>
    <<definition-map>>

    (define (print-and-mult-2 x)
      (display x)
      (newline)
      (* 2 x))

    (head (map print-and-mult-2 (list 1 2 3 4)))
  #+end_src

* Baeume
  Baeume sind genauso wie Listen in erster Linie eine Abstraktion
  ueber Daten.  Listen abstrahieren Daten als eine Sequence die von
  vorne nach hinten durchgeblaettert werden kann.  Das soll uns
  ermoeglichen, ueber Daten als eine Einheit nachdenken zu koennen.

  Listen sind fuer viele Dinge gut, vor allem wenn es um iterative
  Prozesse geht.  Fuer manche Dinge eignen sich Listen allerdings
  nicht so gut, wie zum Beispiel das Finden von Daten, welches nur mit
  einer Zeitkomplexitaet von $O(n)$ realisiert werden kann, selbst
  wenn die Liste bereits sortiert ist.  Listen sind auch nicht so
  toll, wenn es um das hinzufuegen neuer Daten geht.  Das hinzufuegen
  eines Elements zum Beginn einer Liste geht schnell, aber alles
  andere dauert viel laenger.  Zur Erinnerung: Die =append=-Funktion
  muss bis ans Ende der Liste iterieren, wenn es Element angehaengt
  werden soll.
